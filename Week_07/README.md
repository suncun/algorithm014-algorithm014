# Week_07 学习笔记

## Trie树

#### 基本结构

字典树(Trie树)，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。

它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。

#### 基本性质

1. 结点本身不存完整单词
2. 从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串
3. 每个结点的所有子结点路径代表的字符都不相同

#### 核心思想

Trie 树的核心思想是空间换时间。
利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

#### 总结
构建Trie树的过程，需要扫描所有的字符串，时间复杂度是 O(n)（n表示所有字符串的长度和）。
但是一旦构建成功之后，后续的查询操作会非常高效,构建好Trie树后，在其中查找字符串的时间复杂度是 O(k)，k表示要查找的字符串的长度

Trie树最有优势的是查找前缀匹配的字符串，比如搜索引擎中的关键词提示功能这个场景，也是Trie树比较经典的应用场景
Trie树的优势并不在于，用它来做动态集合数据的查找，可以用更加合适的散列表或者红黑树来替代。

leetcode:[实现 Trie (前缀树) ](ImplementTriePrefixTree.java)、[单词搜索 II ](WordSearchIi.java)

## 并查集(Disjoint Set)

并查集是一种树型的数据结构，用于处理不相交集合的合并和查询问题。
并查集解决的场景就是组团和配对问题。比如在有些现实的问题中，需要很快地判断这两个个体是不是在一个集合当中，如微信的朋友圈功能。

并查集主要操作有：
* 合并两个不相交集合；
* 判断两个元素是否属于同一个集合；
* 路径压缩；

并查集模板：

```java
class UnionFind { 
	private int count = 0; 
	private int[] parent; 
	public UnionFind(int n) { 
		count = n; 
		parent = new int[n]; 
		for (int i = 0; i < n; i++) { 
			parent[i] = i;
		}
	} 
	public int find(int p) { 
		while (p != parent[p]) { 
			parent[p] = parent[parent[p]]; 
			p = parent[p]; 
		}
		return p; 
	}
	public void union(int p, int q) { 
		int rootP = find(p); 
		int rootQ = find(q); 
		if (rootP == rootQ) return; 
		parent[rootP] = rootQ; 
		count--;
	}
}
```

并查集题解：[岛屿数量](NumberOfIslands.java)

## 高级搜索

### 剪枝

剪枝是为了提高搜索算法时空效率，在搜索的过程中都难免会计算重复或不需要的东西，我们就可以直接将它剪掉，不计算它，这个过程就被形象地称为剪枝。

### 双向BFS

单向BFS只从起点一端开始搜索，双向BFS则是从起点和终点两边扩展节点，当节点发生重合时即找到最优解。

双向BFS题解：[单词接龙](WordLadder.java)

### 启发式搜索(heuristic search)

##### A* 算法

属于一种启发式搜索算法

* 启发函数(heuristic function)

h(n)，它用来评价哪些结点最有希望的是一个我们要找的结点，h(n)会返回一个非负实数，也可以认为是从结点n的目标结点路径的估计成本。

启发式函数是一种告知搜索方向的方法。它提供了一种明智的方法来猜测哪个邻居结点会导向一个目标。

曼哈顿距离（Manhattan distance），欧几里得距离

曼哈顿距离是两点之间横纵坐标的距离之和， 计算的过程只涉及加减法、符号位反转，所以比欧几里得距离更加高效。

* 估价函数(evaluation function)

启发式搜索算法利用估价函数，避免"跑偏"，贪心地朝着最有可能到达终点的方向前进。

## AVL 树和红黑树

二叉查找树是最常用的一种二叉树，它支持快速插入、删除、查找操作，各个操作的时间复杂度跟树的高度成正比，理想情况下，时间复杂度是 O(logn)。

### AVL 树

AVL树是最先发明的自平衡二叉查找树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。

* Balance Factor（平衡因子）:balance factor = {-1, 0, 1}

* 通过旋转操作来进行平衡（四种）:左旋、右旋、左右旋、右左旋

平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。

缺点：结点需要存储额外信息、且调整次数频繁

### 红黑树

红黑树是一种近似平衡的二叉搜索树（BinarySearch Tree），它能够确保任何一个结点的左右子树的高度差小于两倍。具体来说，红黑树是满足如下条件的二叉搜索树：

* 每个结点要么是红色，要么是黑色

* 根结点是黑色

* 每个叶结点（NIL结点，空结点）是黑色的。

* 不能有相邻接的两个红色结点

* 从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。

**关键性质**：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。

红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似 log2n，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 O(logn)